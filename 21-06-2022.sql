---------------------- task (a) 21-06-2022 -----------------------------------
select c.cust_id, c.cust_name,c.salary,d.dept_id,d.dep_name
from training.customers c
cross join training.dept d
order by c.cust_id;
--output: no.of cols in A * no.of cols in B

select c.cust_id, c.cust_name,c.salary,d.dept_id,d.dep_name
from training.customers c
cross join training.dept d
where c.cust_id < 4
order by c.cust_id;


select 
	c.cust_id ||' '||c.cust_name customer,
	d.dept_id department
from training.customers c
inner join training.customers d
on c.dept_id = d.dept_id
order by c.cust_id;

select * from training.customers
inner join training.dept 
using (dept_id);

select * from training.dept;

update training.customers
set dept_id = 0
where dept_id = 100;

select c.cust_id, c.cust_name, d.dept_id
from training.customers c
natural join training.dept d
order by c.cust_id;

select c.cust_id, c.cust_name, d.dept_id, d.dep_name
from training.customers c
full outer join training.dept d
on c.dept_id = d.dept_id
order by c.cust_id;c

------------------------- task (b) 21-06-2022 -------------------------------
select cust_name, sum(salary) from training.customers
group by cust_name;

select cust_name, sum(salary) from training.customers
group by cust_name
having cust_name like '%L%';

select * from training.customers;
select * from training.dept;

---- subqueries
select cust_id, cust_name from training.customers 
where cust_id in (select cust_id from training.customers 
			 where salary < 30000);

---- correlated subqueries (exists/not exists)
select c.cust_id, c.cust_name from training.customers c
where exists (select d.cust_id from training.customers d
			 where d.salary < 30000
			 and c.cust_id = d.cust_id);
			 
select c.cust_id, c.cust_name from training.customers c
where exists (select d.cust_id from training.customers d
			 where d.salary > 1000000
			 );
			 
select cust_id from training.customers
			 where salary < 30000;
			 
create table training.department
as select * from training.dept 
where dept_id < 3;

---- union, union all, except, intersect
select * from training.dept
union 
select * from training.department;

select * from training.dept
union all
select * from training.department;

select * from training.dept
intersect 
select * from training.department;

select * from training.dept
except
select * from training.department;

-------------------------- task (c) 21-06-2022 --------------------------------
select * from training.employee;
--drop table employee;
--drop table training.employee;
--drop table training.department;

create table training.employee
( emp_id serial primary key,
 emp_name character varying not null default('Eployee101'),
 salary numeric
);

insert into training.employee(emp_name,salary)
values ('Anuja',25000),
	('Emils', 30000),
	('Artemis', 45000);
	
insert into training.employee(salary) values (32000);

---- getting current value of serial ---------
--- pg_get_serial_sequence('training.employee','emp_id')

select currval(pg_get_serial_sequence('training.employee','emp_id')) as now_value;

-------- sequence in postgreSQL ----------------

create sequence training.dept_seq
increment by 1
start 5;

select nextval('training.dept_seq');

insert into training.dept
values (nextval('training.dept_seq'),'INSTRU');

select * from training.dept;

-------------------- task (d) 21-06-2022 -----------------------------------------

--drop table training.employee;

select * from training.employee;

create table training.employee
( emp_id int generated always as identity,
 emp_name varchar(20),
 gender char check( gender in ('M','F'))
);

/*generated as identity: constraint that allows you 
to automatically assign a unique
number to a column
We can have more than one identity columns
*/

alter table training.employee
add dept_id int generated always as identity;

insert into training.employee(emp_name,gender)
values ('AJ','F');

insert into training.employee
values (2,'AK','M');
/*
ERROR:  cannot insert a non-DEFAULT value into column "emp_id"
DETAIL:  Column "emp_id" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.
*/

alter table training.employee
add cabin_num numeric generated by default as identity;
--error: identity column type must be smallint, integer, or bigint

alter table training.employee
add cabin_num bigint generated by default as identity;

insert into training.employee(emp_name,gender,cabin_num)
values ('AK','M',300);
-- generated by default as identity allows insertion

alter table training.employee
alter column dept_id
set generated by default;
-- changing an identity column chracteristic

insert into training.employee(emp_name,gender,dept_id)
values ('SJ','M',5);
--dept_id allowing insertion after alter

alter table training.employee
alter column cabin_num
drop identity if exists;
-- dropping identity on cabin_num

alter table training.employee
rename column cabin_num to office_num;

select * from training.customers;

---------------------- ANY, ALL ------------------------------------------
select cust_id, cust_name from training.customers 
where salary > all
(select salary from training.customers
where cust_id in (2,3));

select cust_id, cust_name from training.customers 
where salary > any
(select salary from training.customers
where cust_id in (2,3));

select cust_id, cust_name from training.customers 
where salary > 
(select min(salary) from training.customers
where cust_id in (2,3));

------------------------- task (e) 21-06-2022 -------------------------------------
drop table training.employee;

create table training.employee
(emp_id serial primary key,
 emp_name varchar(50) not null default('Employee101'),
 emp_phone numeric unique,
 gender char check (gender in ('M','F')),
 dept_id int
);

select * from training.employee;
select * from training.dept;

alter table training.dept
add primary key (dept_id);

alter table training.employee
add constraint fk_dept_id 
foreign key (dept_id)
references training.dept (dept_id);

insert into training.employee(emp_name,emp_phone,gender,dept_id)
values ('Anuja',8806819169,'F',0);

insert into training.employee(emp_name,emp_phone,gender,dept_id)
values ('Anuja',8806819169,'S',0);
--- violating check constraint

insert into training.employee(emp_name,emp_phone,gender,dept_id)
values ('Emils',8806819169,'M',3);
---- violating unique constraint

insert into training.employee(emp_name,emp_phone,gender,dept_id)
values ('Emils',8806819100,'M',8);
--- violating foreign key

insert into training.employee(emp_name,emp_phone,gender,dept_id)
values ('Emils',8806819100,'M',3);
--- successfully inserting

--------------------- operations in postregreSQL --------------------------------

select * from training.customers;

---------- ARITHMETIC OPERATIONS --------------------------------

select salary - (select salary as a_sal from training.customers
where cust_id = 2) as diffrence
from training.customers
where cust_id = 3;
-- 35000-20000

select salary + (select salary as a_sal from training.customers
where cust_id = 2) as addition
from training.customers
where cust_id = 3;
-- 35000+20000

select 2*salary as a_sal from training.customers
where cust_id = 2;
-- 2*20000

select salary/3 as a_sal from training.customers
where cust_id = 2;
-- 20000/3

select salary%4 as a_sal from training.customers
where cust_id = 2;
-- 20000%4

select (salary/40)^2 as a_sal from training.customers
where cust_id = 2;
-- 500^2

select |/((salary/4000)^2) as a_sal from training.customers
where cust_id = 2;
-- square root of 25

select ||/(((salary/4000)^2)+2) as a_sal from training.customers
where cust_id = 2;
-- cube root of 27

-------------------- LOGICAL OPERATORS -----------------------------
-- AND, OR, NOT

select * from training.customers
where cust_id = 2
OR salary > 20000
AND cust_name NOT in ('Luffy');

-------------------- COMPARISON OPERATORS ---------------------------
-- = != <> > < >= <=

-------------------- BITWISE OPERATORS -------------------------------

select cust_id<<1 from training.customers
order by cust_id;
-- cust_id left shifted by 1 ( cust_id * 2)

select cust_id>>1 from training.customers
order by cust_id;
-- cust_id right shifted by 1 (cust_id / 2)

select cust_id&1 from training.customers
order by cust_id;
-- cust_id & (AND) with 1

select cust_id|1 from training.customers
order by cust_id;
-- cust_id | (OR) with 1

select cust_id#1 as XOR from training.customers
order by cust_id;
-- cust_id # (XOR) with 1
--  0 XOR 0 , 1 XOR 1 = 0
